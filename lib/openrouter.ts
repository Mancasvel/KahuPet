interface LLMResponse {
  ingredientes: string[]
  restricciones: string[]
  categorias: string[]
  recomendaciones: string[]
  groupSuggestions?: {
    people: number
    dishIds: string[]
    explanation: string
    funnyResponse: string
  }
}

export async function callOpenRouter(userQuery: string, availableDishes?: any[]): Promise<LLMResponse | null> {
  try {
    // Construir contexto de platos disponibles si se proporciona
    let dishesContext = ""
    if (availableDishes && availableDishes.length > 0) {
      dishesContext = `

PLATOS DISPONIBLES EN NUESTROS RESTAURANTES:
${availableDishes.map(dish => `
- ${dish.name} (${dish.restaurant?.name || 'Restaurante desconocido'})
  Precio: ‚Ç¨${dish.price}
  Ingredientes: ${dish.ingredients?.join(', ') || 'No especificados'}
  Tags: ${dish.tags?.join(', ') || 'No especificados'}
  Descripci√≥n: ${dish.description || 'Sin descripci√≥n'}
`).join('')}
`
    }

    const systemPrompt = `Eres Komi, un asistente de restaurantes que ayuda a encontrar platos perfectos para cada usuario.

Tu trabajo es:
1. Analizar la consulta del usuario para entender qu√© busca
2. Detectar si menciona n√∫mero de personas para sugerir men√∫s para grupos
3. Si tienes informaci√≥n de platos disponibles, recomendar los IDs de los platos m√°s relevantes
4. Extraer criterios de b√∫squeda para encontrar m√°s opciones

Debes devolver √öNICAMENTE un JSON v√°lido con esta estructura:
{
  "ingredientes": [],
  "restricciones": [],
  "categorias": [],
  "recomendaciones": [],
  "groupSuggestions": {
    "people": 0,
    "dishIds": [],
    "explanation": "",
    "funnyResponse": ""
  }
}

Donde:
- ingredientes: ingredientes espec√≠ficos mencionados (ej: "arroz", "pollo", "tomate")
- restricciones: restricciones dietarias o preferencias (ej: "vegano", "sin gluten", "sin picante", "r√°pido", "econ√≥mico", "barato", "premium")
- categorias: tipos de comida o cocina (ej: "espa√±ola", "italiana", "japonesa", "india", "asi√°tica", "tradicional", "casera")
- recomendaciones: IDs de platos espec√≠ficos que recomendar√≠as basado en la consulta (solo si tienes informaci√≥n de platos disponibles)
- groupSuggestions: SOLO si detectas menci√≥n de personas:
  - people: n√∫mero de personas mencionado
  - dishIds: IDs de platos espec√≠ficos que cumplan las restricciones/preferencias mencionadas (seleccionar tantos platos como personas o un m√°ximo de 4)
  - explanation: explicaci√≥n t√©cnica basada en las restricciones reales (precio, tipo de cocina, preferencias)
  - funnyResponse: respuesta contextual que refleje las restricciones/preferencias principales de la b√∫squeda, no solo el tipo de cocina

${dishesContext}

DETECCI√ìN DE GRUPOS Y SITUACIONES: 
- Si menciona n√∫mero de personas: "somos X", "para X personas", "X amigos", "pareja", "familia"
- Si NO menciona personas espec√≠ficas, INFERIR del contexto:
  - "ganado la champions", "celebraci√≥n" ‚Üí asumir grupo de 4 personas (celebraci√≥n)
  - "ingeniero", "trabajo", "reuni√≥n" ‚Üí asumir 2-3 personas (trabajo)
  - "rom√°ntico", "cita" ‚Üí asumir 2 personas
  - "solo", "yo", "para m√≠" ‚Üí asumir 1 persona
  - "familia" ‚Üí asumir 4 personas
  - Si no hay contexto claro ‚Üí asumir 2 personas por defecto

L√ìGICA DE SELECCI√ìN DE PLATOS (SIEMPRE GENERAR ALGO):
1. PRIORIDAD: restricciones (barato, vegano, r√°pido) > categor√≠as (italiana, japonesa) > ingredientes
2. Si menciona restricciones espec√≠ficas: buscar platos que las cumplan
3. Si menciona situaci√≥n especial (celebraci√≥n, trabajo, cita): adaptar la selecci√≥n
4. Si NO hay restricciones claras: seleccionar platos populares/variados
5. SIEMPRE seleccionar n√∫mero de platos = n√∫mero de personas inferido
6. IMPORTANTE: Todos los dishIds deben ser de platos que pertenezcan al mismo restaurante
7. funnyResponse debe ser SIEMPRE contextual y divertida, incluso para consultas vagas

REGLAS PARA funnyResponse:
- Debe ser contextual y relevante a la b√∫squeda espec√≠fica del usuario
- Priorizar restricciones/preferencias sobre tipo de cocina
- Mencionar el n√∫mero de personas de forma natural
- Ser entusiasta y divertida

EJEMPLOS CONTEXTUALES DE funnyResponse (SIEMPRE RESPONDER):
- Restricci√≥n de PRECIO: "somos 3 y queremos barato" ‚Üí "¬°Perfecto! 3 deliciosos platos econ√≥micos que no romper√°n el banco üí∞‚ú®"
- TIPO DE COCINA: "somos 4 y queremos comida italiana" ‚Üí "¬°Mamma mia! La famiglia italiana de 4 est√° servida üçùüë®‚Äçüë©‚Äçüëß‚Äçüë¶"
- RESTRICCI√ìN DIETARIA: "vegano para 2 personas" ‚Üí "¬°Green power! Men√∫ vegano delicioso para 2 üå±üíö"
- CELEBRACI√ìN: "hemos ganado la champions" ‚Üí "¬°CAMPEONES! Men√∫ de celebraci√≥n digno de los ganadores üèÜüéâ"
- TRABAJO/PROFESIONAL: "soy ingeniero de software" ‚Üí "¬°C√≥digo y comida perfecta! Men√∫ para programadores que saben de buen sabor üíªüçΩÔ∏è"
- ROM√ÅNTICO: "algo rom√°ntico" ‚Üí "¬°Amor a primera mordida! Men√∫ rom√°ntico para conquistar corazones üíïüïØÔ∏è"
- VAGO/GENERAL: "quiero algo rico" ‚Üí "¬°Sorpresa culinaria! Selecci√≥n especial de la casa para ti üé≤‚ú®"
- SIN CONTEXTO: consultas vagas ‚Üí "¬°Aventura gastron√≥mica! Te preparamos algo delicioso üåüüç¥"

REGLA CLAVE: NUNCA dejar groupSuggestions vac√≠o. Siempre inferir personas, siempre generar dishIds, siempre dar una respuesta divertida.

Ejemplos:
1. "Quiero algo vegano con arroz" ‚Üí {"ingredientes": ["arroz"], "restricciones": ["vegano"], "categorias": [], "recomendaciones": ["dish_001"], "groupSuggestions": {"people": 0, "dishIds": [], "explanation": "", "funnyResponse": ""}}

2. "Somos 3 y queremos barato" ‚Üí {"ingredientes": [], "restricciones": ["barato"], "categorias": [], "recomendaciones": ["dish_003"], "groupSuggestions": {"people": 3, "dishIds": ["dish_003", "dish_009", "dish_014"], "explanation": "Men√∫ econ√≥mico para 3 personas con platos de buen precio", "funnyResponse": "¬°Perfecto! 3 deliciosos platos econ√≥micos que no romper√°n el banco üí∞‚ú®"}}

3. "Hemos ganado la champions" ‚Üí {"ingredientes": [], "restricciones": [], "categorias": [], "recomendaciones": [], "groupSuggestions": {"people": 4, "dishIds": ["dish_001", "dish_002", "dish_003", "dish_016"], "explanation": "Men√∫ de celebraci√≥n para 4 campeones", "funnyResponse": "¬°CAMPEONES! Men√∫ de celebraci√≥n digno de los ganadores üèÜüéâ"}}

4. "Soy ingeniero de software" ‚Üí {"ingredientes": [], "restricciones": [], "categorias": [], "recomendaciones": [], "groupSuggestions": {"people": 2, "dishIds": ["dish_007", "dish_008"], "explanation": "Men√∫ energ√©tico para programadores", "funnyResponse": "¬°C√≥digo y comida perfecta! Men√∫ para programadores que saben de buen sabor üíªüçΩÔ∏è"}}

IMPORTANTE: 
1. Solo devuelve el JSON, sin explicaciones adicionales.
2. Para groupSuggestions.funnyResponse: SIEMPRE base la respuesta en las restricciones/preferencias mencionadas (barato, vegano, r√°pido, etc.), NO en el tipo de cocina de los platos seleccionados.
3. Si se menciona "barato": la respuesta debe hablar de precios econ√≥micos.
4. Si se menciona "vegano": la respuesta debe hablar de comida vegana.
5. Si se menciona tipo de cocina espec√≠fico: usar respuesta del tipo de cocina.
6. La prioridad es: restricciones dietarias/econ√≥micas > tipo de cocina > ingredientes.`

    const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${process.env.OPENROUTER_API_KEY}`,
        "HTTP-Referer": process.env.YOUR_SITE_URL || "http://localhost:3000",
        "X-Title": process.env.YOUR_SITE_NAME || "Komi",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: "nvidia/llama-3.1-nemotron-ultra-253b-v1:free",
        messages: [
          {
            role: "system",
            content: systemPrompt
          },
          {
            role: "user",
            content: userQuery
          }
        ],
        temperature: 0.1
      })
    })

    if (!response.ok) {
      console.error('OpenRouter API error:', response.status, response.statusText)
      return null
    }

    const data = await response.json()
    
    if (!data.choices || data.choices.length === 0) {
      console.error('No choices in OpenRouter response')
      return null
    }

    const content = data.choices[0].message.content
    
    try {
      // Limpiar el contenido para extraer solo el JSON
      const cleanContent = content.replace(/```json\s*|\s*```/g, '').trim()
      const parsed = JSON.parse(cleanContent)
      
      // Validar estructura
      const result: LLMResponse = {
        ingredientes: Array.isArray(parsed.ingredientes) ? parsed.ingredientes : [],
        restricciones: Array.isArray(parsed.restricciones) ? parsed.restricciones : [],
        categorias: Array.isArray(parsed.categorias) ? parsed.categorias : [],
        recomendaciones: Array.isArray(parsed.recomendaciones) ? parsed.recomendaciones : [],
        groupSuggestions: parsed.groupSuggestions ? {
          people: typeof parsed.groupSuggestions.people === 'number' ? parsed.groupSuggestions.people : 0,
          dishIds: Array.isArray(parsed.groupSuggestions.dishIds) ? parsed.groupSuggestions.dishIds : [],
          explanation: typeof parsed.groupSuggestions.explanation === 'string' ? parsed.groupSuggestions.explanation : '',
          funnyResponse: typeof parsed.groupSuggestions.funnyResponse === 'string' ? parsed.groupSuggestions.funnyResponse : ''
        } : undefined
      }
      
      return result
    } catch (parseError) {
      console.error('Error parsing LLM response:', parseError)
      console.error('Raw content:', content)
      
      // Fallback: crear respuesta basada en palabras clave
      return extractKeywordsFromQuery(userQuery)
    }

  } catch (error) {
    console.error('Error calling OpenRouter:', error)
    return null
  }
}

// Funci√≥n de fallback para extraer palabras clave sin LLM
function extractKeywordsFromQuery(query: string): LLMResponse {
  const lowerQuery = query.toLowerCase()
  
  const commonIngredients = ['arroz', 'pollo', 'carne', 'pescado', 'pasta', 'tomate', 'cebolla', 'ajo', 'queso']
  const commonRestrictions = ['vegano', 'vegetariano', 'sin gluten', 'sin lactosa', 'picante', 'sin picante', 'r√°pido', 'econ√≥mico', 'barato']
  const commonCategories = ['espa√±ola', 'italiana', 'asi√°tica', 'mexicana', 'tradicional', 'casera', 'mediterr√°nea']
  
  // Detectar n√∫mero de personas
  let people = 0
  const peoplePatterns = [
    /somos (\d+)/,
    /(\d+) personas/,
    /para (\d+)/,
    /(\d+) amigos/,
    /(\d+) comensales/
  ]
  
  for (const pattern of peoplePatterns) {
    const match = lowerQuery.match(pattern)
    if (match) {
      people = parseInt(match[1])
      break
    }
  }
  
  // Detectar palabras que sugieren grupos
  if (lowerQuery.includes('pareja') || lowerQuery.includes('rom√°ntica')) {
    people = 2
  } else if (lowerQuery.includes('familia') && people === 0) {
    people = 4
  }
  
  const result: LLMResponse = {
    ingredientes: commonIngredients.filter(ing => lowerQuery.includes(ing)),
    restricciones: commonRestrictions.filter(rest => lowerQuery.includes(rest)),
    categorias: commonCategories.filter(cat => lowerQuery.includes(cat)),
    recomendaciones: [],
    groupSuggestions: people > 0 ? {
      people,
      dishIds: [],
      explanation: `Detectado grupo de ${people} personas`,
      funnyResponse: ''
    } : undefined
  }
  
  return result
} 